diff --git a/Examples/webscript/Download-Modules.ps1 b/Examples/webscript/Download-Modules.ps1
new file mode 100644
index 0000000..e6402e3
--- /dev/null
+++ b/Examples/webscript/Download-Modules.ps1
@@ -0,0 +1,20 @@
+
+function Download-Modules {
+    param (
+        [array]$scriptDetails  # Array of script details, including URLs
+    )
+
+    $processList = [System.Collections.Generic.List[System.Diagnostics.Process]]::new()
+
+    foreach ($scriptDetail in $scriptDetails) {
+        $process = Invoke-WebScript -url $scriptDetail.Url
+        if ($process) {
+            $processList.Add($process)
+        }
+    }
+
+    # Optionally wait for all processes to complete
+    foreach ($process in $processList) {
+        $process.WaitForExit()
+    }
+}
\ No newline at end of file
diff --git a/Examples/webscript/Install-GitFromWeb.ps1 b/Examples/webscript/Install-GitFromWeb.ps1
new file mode 100644
index 0000000..db4c946
--- /dev/null
+++ b/Examples/webscript/Install-GitFromWeb.ps1
@@ -0,0 +1,36 @@
+function Install-GitFromWeb {
+    param (
+        [string]$url = "https://raw.githubusercontent.com/aollivierre/setuplab/main/Install-Git.ps1"
+    )
+
+    Write-EnhancedLog -Message "Attempting to install Git from URL: $url" -Level "INFO"
+
+    $process = Invoke-WebScript -url $url
+    if ($process) {
+        $process.WaitForExit()
+
+        # Perform post-installation validation
+        $validationParams = @{
+            SoftwareName        = "Git"
+            MinVersion          = [version]"2.46.0"
+            RegistryPath        = "HKLM:\SOFTWARE\GitForWindows"
+            ExePath             = "C:\Program Files\Git\bin\git.exe"
+            MaxRetries          = 3  # Single retry after installation
+            DelayBetweenRetries = 5
+        }
+
+        $postValidationResult = Validate-SoftwareInstallation @validationParams
+        if ($postValidationResult.IsInstalled -and $postValidationResult.Version -ge $validationParams.MinVersion) {
+            Write-EnhancedLog -Message "Git successfully installed and validated." -Level "INFO"
+            return $true
+        }
+        else {
+            Write-EnhancedLog -Message "Git installation validation failed." -Level "ERROR"
+            return $false
+        }
+    }
+    else {
+        Write-EnhancedLog -Message "Failed to start the installation process for Git." -Level "ERROR"
+        return $false
+    }
+}
\ No newline at end of file
diff --git a/Examples/webscript/Install-PowerShell7FromWeb.ps1 b/Examples/webscript/Install-PowerShell7FromWeb.ps1
new file mode 100644
index 0000000..2449419
--- /dev/null
+++ b/Examples/webscript/Install-PowerShell7FromWeb.ps1
@@ -0,0 +1,37 @@
+
+function Install-PowerShell7FromWeb {
+    param (
+        [string]$url = "https://raw.githubusercontent.com/aollivierre/setuplab/main/Install-PowerShell7.ps1"
+    )
+
+    Write-EnhancedLog -Message "Attempting to install PowerShell 7 from URL: $url" -Level "INFO"
+
+    $process = Invoke-WebScript -url $url
+    if ($process) {
+        $process.WaitForExit()
+
+        # Perform post-installation validation
+        $validationParams = @{
+            SoftwareName        = "PowerShell"
+            MinVersion          = [version]"7.4.4"
+            RegistryPath        = "HKLM:\SOFTWARE\Microsoft\PowerShellCore"
+            ExePath             = "C:\Program Files\PowerShell\7\pwsh.exe"
+            MaxRetries          = 3  # Single retry after installation
+            DelayBetweenRetries = 5
+        }
+
+        $postValidationResult = Validate-SoftwareInstallation @validationParams
+        if ($postValidationResult.IsInstalled -and $postValidationResult.Version -ge $validationParams.MinVersion) {
+            Write-EnhancedLog -Message "PowerShell 7 successfully installed and validated." -Level "INFO"
+            return $true
+        }
+        else {
+            Write-EnhancedLog -Message "PowerShell 7 installation validation failed." -Level "ERROR"
+            return $false
+        }
+    }
+    else {
+        Write-EnhancedLog -Message "Failed to start the installation process for PowerShell 7." -Level "ERROR"
+        return $false
+    }
+}
\ No newline at end of file
diff --git a/Examples/webscript/Invoke-WebScript.ps1 b/Examples/webscript/Invoke-WebScript.ps1
new file mode 100644
index 0000000..69debfc
--- /dev/null
+++ b/Examples/webscript/Invoke-WebScript.ps1
@@ -0,0 +1,34 @@
+
+function Invoke-WebScript {
+    param (
+        [string]$url
+    )
+
+    $powerShellPath = Get-PowerShellPath -ForcePowerShell5
+
+    Write-EnhancedLog -Message "Validating URL: $url" -Level "INFO"
+
+    if (Test-Url -url $url) {
+        Write-EnhancedLog -Message "Running script from URL: $url" -Level "INFO"
+
+        $startProcessParams = @{
+            FilePath     = $powerShellPath
+            ArgumentList = @(
+                "-NoExit",
+                "-NoProfile",
+                "-ExecutionPolicy", "Bypass",
+                "-Command", "Invoke-Expression (Invoke-RestMethod -Uri '$url')"
+            )
+            Verb         = "RunAs"
+            PassThru     = $true
+        }
+        
+        $process = Start-Process @startProcessParams
+        
+        return $process
+    }
+    else {
+        Write-EnhancedLog -Message "URL $url is not accessible" -Level "ERROR"
+        return $null
+    }
+}
\ No newline at end of file
diff --git a/Examples/webscript/PowerShell Script Execution from URLs Guide.md b/Examples/webscript/PowerShell Script Execution from URLs Guide.md
new file mode 100644
index 0000000..08885d2
--- /dev/null
+++ b/Examples/webscript/PowerShell Script Execution from URLs Guide.md	
@@ -0,0 +1,165 @@
+# PowerShell Script Execution from URLs Guide
+
+This guide explains different methods of executing PowerShell scripts from URLs, with a focus on security implications and best practices.
+
+## Table of Contents
+
+- [PowerShell Script Execution from URLs Guide](#powershell-script-execution-from-urls-guide)
+  - [Table of Contents](#table-of-contents)
+  - [Example Script](#example-script)
+  - [Method 1: Direct Memory Execution (Invoke-Expression)](#method-1-direct-memory-execution-invoke-expression)
+    - [Characteristics of Memory Execution](#characteristics-of-memory-execution)
+  - [Method 2: Download and Execute (Safer Approach)](#method-2-download-and-execute-safer-approach)
+    - [Characteristics of Download Method](#characteristics-of-download-method)
+  - [Method 3: Using Invoke-WebRequest with Direct Execution](#method-3-using-invoke-webrequest-with-direct-execution)
+    - [Characteristics of Invoke-WebRequest](#characteristics-of-invoke-webrequest)
+  - [Security Considerations](#security-considerations)
+    - [When Using Raw GitHub URLs](#when-using-raw-github-urls)
+    - [General Security Best Practices](#general-security-best-practices)
+  - [Execution Policy Notes](#execution-policy-notes)
+  - [Troubleshooting Tips](#troubleshooting-tips)
+    - [Common Issues](#common-issues)
+  - [Example Usage for Our Script](#example-usage-for-our-script)
+    - [Memory-Only Execution](#memory-only-execution)
+    - [Download and Verify](#download-and-verify)
+  - [Additional Resources](#additional-resources)
+
+## Example Script
+
+Our example uses a network configuration script located at:
+
+```powershell
+https://raw.githubusercontent.com/aollivierre/HyperV/refs/heads/main/2-Create-HyperV_VM/Latest/Prepare%20Server%20Core%20Domain%20Controller/1-Set-Static-IPV4-from-DHCP-Configs.ps1
+```
+
+## Method 1: Direct Memory Execution (Invoke-Expression)
+
+```powershell
+Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('YOUR_SCRIPT_URL'))
+```
+
+### Characteristics of Memory Execution
+
+- Script runs directly in memory
+- No file is saved to disk
+- Faster execution
+- Harder to inspect before execution
+- Memory-only footprint
+- Good for one-time execution
+- Less secure as script content can't be easily verified before execution
+
+## Method 2: Download and Execute (Safer Approach)
+
+```powershell
+$scriptUrl = 'YOUR_SCRIPT_URL'
+$outputPath = "$env:TEMP\Script.ps1"
+Invoke-WebRequest -Uri $scriptUrl -OutFile $outputPath
+Get-Content $outputPath | Write-Host
+Read-Host "Press Enter to execute the script"
+Set-ExecutionPolicy Bypass -Scope Process -Force
+& $outputPath
+```
+
+### Characteristics of Download Method
+
+- Script is downloaded to disk first
+- Can be inspected before execution
+- Creates a local copy for reference
+- More control over the execution process
+- Better for security auditing
+- Allows for script verification before execution
+- Required for scripts using `$PSScriptRoot` or similar automatic variables that depend on file paths
+- Better for scripts that need to reference their own location or relative paths
+
+## Method 3: Using Invoke-WebRequest with Direct Execution
+
+```powershell
+$scriptUrl = 'YOUR_SCRIPT_URL'
+Set-ExecutionPolicy Bypass -Scope Process -Force
+Invoke-WebRequest -Uri $scriptUrl -UseBasicParsing | Select-Object -ExpandProperty Content | Invoke-Expression
+```
+
+### Characteristics of Invoke-WebRequest
+
+- Modern alternative to WebClient
+- Better handling of special characters in URLs
+- Supports more authentication methods
+- More features like progress tracking
+- Still runs in memory
+- More robust error handling
+
+## Security Considerations
+
+### When Using Raw GitHub URLs
+
+1. Always use the `raw.githubusercontent.com` domain
+2. Ensure you're using the correct branch (e.g., `main`, `master`)
+3. URL format should be: `https://raw.githubusercontent.com/USER/REPO/BRANCH/PATH/TO/SCRIPT`
+
+### General Security Best Practices
+
+1. **Always verify the source** of the script
+2. Use **HTTPS** URLs only
+3. Consider using **script signing** for production environments
+4. Implement **hash verification** for critical scripts
+5. Use `-UseBasicParsing` with `Invoke-WebRequest` for better compatibility
+6. Consider using `-ExecutionPolicy` scoped to `Process` only
+7. Avoid storing credentials in scripts
+8. Review scripts before execution when possible
+
+## Execution Policy Notes
+
+```powershell
+# Temporary bypass for current process only
+Set-ExecutionPolicy Bypass -Scope Process -Force
+
+# More restrictive alternatives
+Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
+Set-ExecutionPolicy AllSigned -Scope CurrentUser
+```
+
+## Troubleshooting Tips
+
+### Common Issues
+
+1. **SSL/TLS Errors**: Ensure you're using TLS 1.2 or higher
+
+   ```powershell
+   [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
+   ```
+
+2. **URL Encoding Issues**: Use `[System.Web.HttpUtility]::UrlEncode()` for complex URLs
+
+3. **Proxy Considerations**: Use `-Proxy` parameter with `Invoke-WebRequest` if needed
+
+4. **Timeout Issues**: Adjust timeout settings for large scripts
+
+   ```powershell
+   $webClient.Timeout = 30000  # 30 seconds
+   ```
+
+## Example Usage for Our Script
+
+### Memory-Only Execution
+
+```powershell
+Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/aollivierre/HyperV/refs/heads/main/2-Create-HyperV_VM/Latest/Prepare%20Server%20Core%20Domain%20Controller/1-Set-Static-IPV4-from-DHCP-Configs.ps1'))
+```
+
+### Download and Verify
+
+```powershell
+$scriptUrl = 'https://raw.githubusercontent.com/aollivierre/HyperV/refs/heads/main/2-Create-HyperV_VM/Latest/Prepare%20Server%20Core%20Domain%20Controller/1-Set-Static-IPV4-from-DHCP-Configs.ps1'
+$outputPath = "$env:TEMP\Set-Static-IPV4.ps1"
+Invoke-WebRequest -Uri $scriptUrl -OutFile $outputPath
+Get-Content $outputPath | Write-Host
+Read-Host "Press Enter to execute the script"
+Set-ExecutionPolicy Bypass -Scope Process -Force
+& $outputPath
+```
+
+## Additional Resources
+
+- [PowerShell Security Documentation](https://docs.microsoft.com/en-us/powershell/scripting/learn/security-features)
+- [About Execution Policies](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies)
+- [Invoke-WebRequest Documentation](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest)
diff --git a/Examples/webscript/check.ps1 b/Examples/webscript/check.ps1
new file mode 100644
index 0000000..782e5af
--- /dev/null
+++ b/Examples/webscript/check.ps1
@@ -0,0 +1,753 @@
+#Unique Tracking ID: 0fe95769-ac53-49ef-9c81-3e73bfd8545d, Timestamp: 2024-06-09 12:07:36
+# JSON string
+$json = @'
+{
+  "PackageName": "PR4B - Install Pending Windows Updates",
+  "PackageUniqueGUID": "f19844c1-d77a-4d59-883f-8fec027a3458",
+  "Version": 1,
+  "PackageExecutionContext": "SYSTEM",
+  "LoggingDeploymentName": "PR4B_TriggerWindowsUpdatesCustomlog",
+  "ScriptMode": "Remediation",
+  "RunOnDemand": false,
+  "UsePSADT": false,
+  "TriggerType": "Daily",
+  "LogonUserId": "administrator",
+  "RepetitionInterval": "P1D"
+}
+'@
+
+# Convert JSON string to a PowerShell object
+$Config = $json | ConvertFrom-Json
+
+# Assign values from JSON to variables
+$PackageName = $config.PackageName
+$PackageUniqueGUID = $config.PackageUniqueGUID
+$Version = $config.Version
+$PackageExecutionContext = $config.PackageExecutionContext
+# $RepetitionInterval = $config.RepetitionInterval
+$ScriptMode = $config.ScriptMode
+
+# Assign values from JSON to variables
+$LoggingDeploymentName = $config.LoggingDeploymentName
+    
+function Initialize-ScriptAndLogging {
+    $ErrorActionPreference = 'SilentlyContinue'
+    $deploymentName = "$LoggingDeploymentName" # Replace this with your actual deployment name
+    $scriptPath = "C:\code\$deploymentName"
+    # $hadError = $false
+    
+    try {
+        if (-not (Test-Path -Path $scriptPath)) {
+            New-Item -ItemType Directory -Path $scriptPath -Force | Out-Null
+            Write-Host "Created directory: $scriptPath"
+        }
+    
+        $computerName = $env:COMPUTERNAME
+        $Filename = "$LoggingDeploymentName"
+        $logDir = Join-Path -Path $scriptPath -ChildPath "exports\Logs\$computerName"
+        $logPath = Join-Path -Path $logDir -ChildPath "$(Get-Date -Format 'yyyy-MM-dd-HH-mm-ss')"
+            
+        if (!(Test-Path $logPath)) {
+            Write-Host "Did not find log file at $logPath" -ForegroundColor Yellow
+            Write-Host "Creating log file at $logPath" -ForegroundColor Yellow
+            $createdLogDir = New-Item -ItemType Directory -Path $logPath -Force -ErrorAction Stop
+            Write-Host "Created log file at $logPath" -ForegroundColor Green
+        }
+            
+        $logFile = Join-Path -Path $logPath -ChildPath "$Filename-Transcript.log"
+        Start-Transcript -Path $logFile -ErrorAction Stop | Out-Null
+    
+        $CSVDir = Join-Path -Path $scriptPath -ChildPath "exports\CSV"
+        $CSVFilePath = Join-Path -Path $CSVDir -ChildPath "$computerName"
+            
+        if (!(Test-Path $CSVFilePath)) {
+            Write-Host "Did not find CSV file at $CSVFilePath" -ForegroundColor Yellow
+            Write-Host "Creating CSV file at $CSVFilePath" -ForegroundColor Yellow
+            $createdCSVDir = New-Item -ItemType Directory -Path $CSVFilePath -Force -ErrorAction Stop
+            Write-Host "Created CSV file at $CSVFilePath" -ForegroundColor Green
+        }
+    
+        return @{
+            ScriptPath  = $scriptPath
+            Filename    = $Filename
+            LogPath     = $logPath
+            LogFile     = $logFile
+            CSVFilePath = $CSVFilePath
+        }
+    
+    }
+    catch {
+        Write-Error "An error occurred while initializing script and logging: $_"
+    }
+}
+$initializationInfo = Initialize-ScriptAndLogging
+    
+    
+    
+# Script Execution and Variable Assignment
+# After the function Initialize-ScriptAndLogging is called, its return values (in the form of a hashtable) are stored in the variable $initializationInfo.
+    
+# Then, individual elements of this hashtable are extracted into separate variables for ease of use:
+    
+# $ScriptPath: The path of the script's main directory.
+# $Filename: The base name used for log files.
+# $logPath: The full path of the directory where logs are stored.
+# $logFile: The full path of the transcript log file.
+# $CSVFilePath: The path of the directory where CSV files are stored.
+# This structure allows the script to have a clear organization regarding where logs and other files are stored, making it easier to manage and maintain, especially for logging purposes. It also encapsulates the setup logic in a function, making the main script cleaner and more focused on its primary tasks.
+    
+    
+$ScriptPath = $initializationInfo['ScriptPath']
+$Filename = $initializationInfo['Filename']
+$logPath = $initializationInfo['LogPath']
+$logFile = $initializationInfo['LogFile']
+$CSVFilePath = $initializationInfo['CSVFilePath']
+    
+    
+    
+    
+function AppendCSVLog {
+    param (
+        [string]$Message,
+        [string]$CSVFilePath
+           
+    )
+    
+    $csvData = [PSCustomObject]@{
+        TimeStamp    = (Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
+        ComputerName = $env:COMPUTERNAME
+        Message      = $Message
+    }
+    
+    $csvData | Export-Csv -Path $CSVFilePath -Append -NoTypeInformation -Force
+}
+    
+    
+    
+function CreateEventSourceAndLog {
+    param (
+        [string]$LogName,
+        [string]$EventSource
+    )
+    
+    
+    # Validate parameters
+    if (-not $LogName) {
+        Write-Warning "LogName is required."
+        return
+    }
+    if (-not $EventSource) {
+        Write-Warning "Source is required."
+        return
+    }
+    
+    # Function to create event log and source
+    function CreateEventLogSource($logName, $EventSource) {
+        try {
+            if ($PSVersionTable.PSVersion.Major -lt 6) {
+                New-EventLog -LogName $logName -Source $EventSource
+            }
+            else {
+                [System.Diagnostics.EventLog]::CreateEventSource($EventSource, $logName)
+            }
+            Write-Host "Event source '$EventSource' created in log '$logName'" -ForegroundColor Green
+        }
+        catch {
+            Write-Warning "Error creating the event log. Make sure you run PowerShell as an Administrator."
+        }
+    }
+    
+    # Check if the event log exists
+    if (-not (Get-WinEvent -ListLog $LogName -ErrorAction SilentlyContinue)) {
+        # CreateEventLogSource $LogName $EventSource
+    }
+    # Check if the event source exists
+    elseif (-not ([System.Diagnostics.EventLog]::SourceExists($EventSource))) {
+        # Unregister the source if it's registered with a different log
+        $existingLogName = (Get-WinEvent -ListLog * | Where-Object { $_.LogName -contains $EventSource }).LogName
+        if ($existingLogName -ne $LogName) {
+            Remove-EventLog -Source $EventSource -ErrorAction SilentlyContinue
+        }
+        # CreateEventLogSource $LogName $EventSource
+    }
+    else {
+        Write-Host "Event source '$EventSource' already exists in log '$LogName'" -ForegroundColor Yellow
+    }
+}
+    
+$LogName = (Get-Date -Format "HHmmss") + "_$LoggingDeploymentName"
+$EventSource = (Get-Date -Format "HHmmss") + "_$LoggingDeploymentName"
+    
+# Call the Create-EventSourceAndLog function
+CreateEventSourceAndLog -LogName $LogName -EventSource $EventSource
+    
+# Call the Write-CustomEventLog function with custom parameters and level
+# Write-CustomEventLog -LogName $LogName -EventSource $EventSource -EventMessage "Outlook Signature Restore completed with warnings." -EventID 1001 -Level 'WARNING'
+    
+    
+    
+    
+# function Write-EventLogMessage {
+#     param (
+#         [Parameter(Mandatory = $true)]
+#         [ValidateNotNullOrEmpty()]
+#         [string]$Message,
+    
+#         [string]$LogName = "$LoggingDeploymentName",
+#         [string]$EventSource,
+    
+#         [int]$EventID = 1000  # Default event ID
+#     )
+    
+#     $ErrorActionPreference = 'SilentlyContinue'
+#     $hadError = $false
+    
+#     try {
+#         if (-not $EventSource) {
+#             throw "EventSource is required."
+#         }
+    
+#         if ($PSVersionTable.PSVersion.Major -lt 6) {
+#             # PowerShell version is less than 6, use Write-EventLog
+#             Write-EventLog -LogName $logName -Source $EventSource -EntryType Information -EventId $EventID -Message $Message
+#         }
+#         else {
+#             # PowerShell version is 6 or greater, use System.Diagnostics.EventLog
+#             $eventLog = New-Object System.Diagnostics.EventLog($logName)
+#             $eventLog.Source = $EventSource
+#             $eventLog.WriteEntry($Message, [System.Diagnostics.EventLogEntryType]::Information, $EventID)
+#         }
+    
+#         # Write-host "Event log entry created: $Message" 
+#     }
+#     catch {
+#         Write-Host "Error creating event log entry: $_" 
+#         $hadError = $true
+#     }
+    
+#     if (-not $hadError) {
+#         # Write-host "Event log message writing completed successfully."
+#     }
+# }
+    
+    
+    
+    
+function Write-EnhancedLog {
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
+        [string]$CSVFilePath = "$scriptPath\exports\CSV\$(Get-Date -Format 'yyyy-MM-dd')-Log.csv",
+        [string]$CentralCSVFilePath = "$scriptPath\exports\CSV\$Filename.csv",
+        [switch]$UseModule = $false,
+        [string]$Caller = (Get-PSCallStack)[0].Command
+    )
+    
+    # Add timestamp, computer name, and log level to the message
+    $formattedMessage = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') $($env:COMPUTERNAME): [$Level] [$Caller] $Message"
+    
+    # Set foreground color based on log level
+    switch ($Level) {
+        'INFO' { $ForegroundColor = [ConsoleColor]::Green }
+        'WARNING' { $ForegroundColor = [ConsoleColor]::Yellow }
+        'ERROR' { $ForegroundColor = [ConsoleColor]::Red }
+    }
+    
+    # Write the message with the specified colors
+    $currentForegroundColor = $Host.UI.RawUI.ForegroundColor
+    $Host.UI.RawUI.ForegroundColor = $ForegroundColor
+    # Write-output $formattedMessage
+    Write-Host $formattedMessage
+    $Host.UI.RawUI.ForegroundColor = $currentForegroundColor
+    
+    # Append to CSV file
+    AppendCSVLog -Message $formattedMessage -CSVFilePath $CSVFilePath
+    AppendCSVLog -Message $formattedMessage -CSVFilePath $CentralCSVFilePath
+    
+    # Write to event log (optional)
+    # Write-CustomEventLog -EventMessage $formattedMessage -Level $Level
+
+    
+    # Adjust this line in your script where you call the function
+    # Write-EventLogMessage -LogName $LogName -EventSource $EventSource -Message $formattedMessage -EventID 1001
+    
+}
+    
+# function Export-EventLog {
+#     param (
+#         [Parameter(Mandatory = $true)]
+#         [string]$LogName,
+#         [Parameter(Mandatory = $true)]
+#         [string]$ExportPath
+#     )
+    
+#     try {
+#         wevtutil epl $LogName $ExportPath
+    
+#         if (Test-Path $ExportPath) {
+#             Write-EnhancedLog -Message "Event log '$LogName' exported to '$ExportPath'" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+#         }
+#         else {
+#             Write-EnhancedLog -Message "Event log '$LogName' not exported: File does not exist at '$ExportPath'" -Level "WARNING" -ForegroundColor ([ConsoleColor]::Yellow)
+#         }
+#     }
+#     catch {
+#         Write-EnhancedLog -Message "Error exporting event log '$LogName': $($_.Exception.Message)" -Level "ERROR" -ForegroundColor ([ConsoleColor]::Red)
+#     }
+# }
+    
+# # Example usage
+# $LogName = '$LoggingDeploymentNameLog'
+# # $ExportPath = 'Path\to\your\exported\eventlog.evtx'
+# $ExportPath = "C:\code\$LoggingDeploymentName\exports\Logs\$logname.evtx"
+# Export-EventLog -LogName $LogName -ExportPath $ExportPath
+    
+    
+    
+    
+    
+    
+#################################################################################################################################
+################################################# END LOGGING ###################################################################
+#################################################################################################################################
+    
+    
+    
+Write-EnhancedLog -Message "Logging works" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+
+#################################################################################################################################
+################################################# END LOGGING ###################################################################
+#################################################################################################################################
+    
+
+
+
+
+function Test-RunningAsSystem {
+    $systemSid = New-Object System.Security.Principal.SecurityIdentifier "S-1-5-18"
+    $currentSid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User
+
+    return $currentSid -eq $systemSid
+}
+
+
+function CheckAndElevate {
+
+    <#
+.SYNOPSIS
+Elevates the script to run with administrative privileges if not already running as an administrator.
+
+.DESCRIPTION
+The CheckAndElevate function checks if the current PowerShell session is running with administrative privileges. If it is not, the function attempts to restart the script with elevated privileges using the 'RunAs' verb. This is useful for scripts that require administrative privileges to perform their tasks.
+
+.EXAMPLE
+CheckAndElevate
+
+Checks the current session for administrative privileges and elevates if necessary.
+
+.NOTES
+This function will cause the script to exit and restart if it is not already running with administrative privileges. Ensure that any state or data required after elevation is managed appropriately.
+#>
+    [CmdletBinding()]
+    param (
+        # Advanced parameters could be added here if needed. For this function, parameters aren't strictly necessary,
+        # but you could, for example, add parameters to control logging behavior or to specify a different method of elevation.
+        # [switch]$Elevated
+    )
+
+    begin {
+        try {
+            $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
+            $isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
+
+            Write-EnhancedLog -Message "Checking for administrative privileges..." -Level "INFO" -ForegroundColor ([ConsoleColor]::Blue)
+        }
+        catch {
+            Write-EnhancedLog -Message "Error determining administrative status: $_" -Level "ERROR" -ForegroundColor ([ConsoleColor]::Red)
+            throw $_
+        }
+    }
+
+    process {
+        if (-not $isAdmin) {
+            try {
+                Write-EnhancedLog -Message "The script is not running with administrative privileges. Attempting to elevate..." -Level "WARNING" -ForegroundColor ([ConsoleColor]::Yellow)
+                
+                $arguments = "-NoProfile -ExecutionPolicy Bypass -NoExit -File `"$PSCommandPath`" $args"
+                Start-Process PowerShell -Verb RunAs -ArgumentList $arguments
+
+                # Invoke-AsSystem -PsExec64Path $PsExec64Path
+                
+                Write-EnhancedLog -Message "Script re-launched with administrative privileges. Exiting current session." -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+                exit
+            }
+            catch {
+                Write-EnhancedLog -Message "Failed to elevate privileges: $_" -Level "ERROR" -ForegroundColor ([ConsoleColor]::Red)
+                throw $_
+            }
+        }
+        else {
+            Write-EnhancedLog -Message "Script is already running with administrative privileges." -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+        }
+    }
+
+    end {
+        # This block is typically used for cleanup. In this case, there's nothing to clean up,
+        # but it's useful to know about this structure for more complex functions.
+    }
+}
+
+
+
+function Remove-ExistingPsExec {
+    [CmdletBinding()]
+    param(
+        [string]$TargetFolder = "$PSScriptRoot\private"
+    )
+
+    # Full path for PsExec64.exe
+    $PsExec64Path = Join-Path -Path $TargetFolder -ChildPath "PsExec64.exe"
+
+    try {
+        # Check if PsExec64.exe exists
+        if (Test-Path -Path $PsExec64Path) {
+            Write-EnhancedLog -Message "Removing existing PsExec64.exe from: $TargetFolder"
+            # Remove PsExec64.exe
+            Remove-Item -Path $PsExec64Path -Force
+            Write-Output "PsExec64.exe has been removed from: $TargetFolder"
+        }
+        else {
+            Write-EnhancedLog -Message "No PsExec64.exe file found in: $TargetFolder"
+        }
+    }
+    catch {
+        # Handle any errors during the removal
+        Write-Error "An error occurred while trying to remove PsExec64.exe: $_"
+    }
+}
+
+
+
+
+
+
+function Download-PsExec {
+    [CmdletBinding()]
+    param(
+        [string]$TargetFolder = "$PSScriptRoot\private"
+    )
+
+    Begin {
+
+        Remove-ExistingPsExec
+    }
+
+
+
+    process {
+
+        # Define the URL for PsExec download
+        $url = "https://download.sysinternals.com/files/PSTools.zip"
+    
+        # Ensure the target folder exists
+        if (-Not (Test-Path -Path $TargetFolder)) {
+            New-Item -Path $TargetFolder -ItemType Directory
+        }
+  
+        # Full path for the downloaded file
+        $zipPath = Join-Path -Path $TargetFolder -ChildPath "PSTools.zip"
+  
+        try {
+            # Download the PSTools.zip file containing PsExec
+            Write-EnhancedLog -Message "Downloading PSTools.zip from: $url to: $zipPath"
+            Invoke-WebRequest -Uri $url -OutFile $zipPath
+  
+            # Extract PsExec64.exe from the zip file
+            Expand-Archive -Path $zipPath -DestinationPath "$TargetFolder\PStools" -Force
+  
+            # Specific extraction of PsExec64.exe
+            $extractedFolderPath = Join-Path -Path $TargetFolder -ChildPath "PSTools"
+            $PsExec64Path = Join-Path -Path $extractedFolderPath -ChildPath "PsExec64.exe"
+            $finalPath = Join-Path -Path $TargetFolder -ChildPath "PsExec64.exe"
+  
+            # Move PsExec64.exe to the desired location
+            if (Test-Path -Path $PsExec64Path) {
+  
+                Write-EnhancedLog -Message "Moving PSExec64.exe from: $PsExec64Path to: $finalPath"
+                Move-Item -Path $PsExec64Path -Destination $finalPath
+  
+                # Remove the downloaded zip file and extracted folder
+                Remove-Item -Path $zipPath -Force
+                Remove-Item -Path $extractedFolderPath -Recurse -Force
+  
+                Write-EnhancedLog -Message "PsExec64.exe has been successfully downloaded and moved to: $finalPath"
+            }
+        }
+        catch {
+            # Handle any errors during the process
+            Write-Error "An error occurred: $_"
+        }
+    }
+
+
+  
+
+}
+
+
+
+
+function Invoke-AsSystem {
+    <#
+.SYNOPSIS
+Executes a PowerShell script under the SYSTEM context, similar to Intune's execution context.
+
+.DESCRIPTION
+The Invoke-AsSystem function executes a PowerShell script using PsExec64.exe to run under the SYSTEM context. This method is useful for scenarios requiring elevated privileges beyond the current user's capabilities.
+
+.PARAMETER PsExec64Path
+Specifies the full path to PsExec64.exe. If not provided, it assumes PsExec64.exe is in the same directory as the script.
+
+.EXAMPLE
+Invoke-AsSystem -PsExec64Path "C:\Tools\PsExec64.exe"
+
+Executes PowerShell as SYSTEM using PsExec64.exe located at "C:\Tools\PsExec64.exe".
+
+.NOTES
+Ensure PsExec64.exe is available and the script has the necessary permissions to execute it.
+
+.LINK
+https://docs.microsoft.com/en-us/sysinternals/downloads/psexec
+#>
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$PsExec64Path,
+        [string]$ScriptPathAsSYSTEM  # Path to the PowerShell script you want to run as SYSTEM
+    )
+
+    begin {
+        CheckAndElevate
+        # Define the arguments for PsExec64.exe to run PowerShell as SYSTEM with the script
+        $argList = "-accepteula -i -s -d powershell.exe -NoExit -ExecutionPolicy Bypass -File `"$ScriptPathAsSYSTEM`""
+        Write-EnhancedLog -Message "Preparing to execute PowerShell as SYSTEM using PsExec64 with the script: $ScriptPathAsSYSTEM" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+
+        Download-PsExec
+    }
+
+    process {
+        try {
+            # Ensure PsExec64Path exists
+            if (-not (Test-Path -Path $PsExec64Path)) {
+                $errorMessage = "PsExec64.exe not found at path: $PsExec64Path"
+                Write-EnhancedLog -Message $errorMessage -Level "ERROR" -ForegroundColor ([ConsoleColor]::Red)
+                throw $errorMessage
+            }
+
+            # Run PsExec64.exe with the defined arguments to execute the script as SYSTEM
+            $executingMessage = "Executing PsExec64.exe to start PowerShell as SYSTEM running script: $ScriptPathAsSYSTEM"
+            Write-EnhancedLog -Message $executingMessage -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+            Start-Process -FilePath "$PsExec64Path" -ArgumentList $argList -Wait -NoNewWindow
+            
+            Write-EnhancedLog -Message "SYSTEM session started. Closing elevated session..." -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+            exit
+
+        }
+        catch {
+            Write-EnhancedLog -Message "An error occurred: $_" -Level "ERROR" -ForegroundColor ([ConsoleColor]::Red)
+        }
+    }
+}
+
+
+
+
+# Assuming Invoke-AsSystem and Write-EnhancedLog are already defined
+# Update the path to your actual location of PsExec64.exe
+
+Write-EnhancedLog -Message "calling Test-RunningAsSystem" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+if (-not (Test-RunningAsSystem)) {
+    $privateFolderPath = Join-Path -Path $PSScriptRoot -ChildPath "private"
+    $PsExec64Path = Join-Path -Path $privateFolderPath -ChildPath "PsExec64.exe"
+
+    Write-EnhancedLog -Message "Current session is not running as SYSTEM. Attempting to invoke as SYSTEM..." -Level "INFO" -ForegroundColor ([ConsoleColor]::Yellow)
+
+    $ScriptToRunAsSystem = $MyInvocation.MyCommand.Path
+    Invoke-AsSystem -PsExec64Path $PsExec64Path -ScriptPath $ScriptToRunAsSystem
+
+}
+else {
+    Write-EnhancedLog -Message "Session is already running as SYSTEM." -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+}
+
+
+    
+    
+#################################################################################################################################
+################################################# END LOGGING ###################################################################
+#################################################################################################################################
+
+
+
+Write-EnhancedLog -Message "calling Test-RunningAsSystem" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+
+
+function Set-LocalPathBasedOnContext {
+    Write-EnhancedLog -Message "Checking running context..." -Level "INFO" -ForegroundColor ([System.ConsoleColor]::Cyan)
+    if (Test-RunningAsSystem) {
+        Write-EnhancedLog -Message "Running as system, setting path to Program Files" -Level "INFO" -ForegroundColor ([System.ConsoleColor]::Yellow)
+        return "$ENV:Programfiles\_MEM"
+    }
+    else {
+        Write-EnhancedLog -Message "Running as user, setting path to Local AppData" -Level "INFO" -ForegroundColor ([System.ConsoleColor]::Yellow)
+        return "$ENV:LOCALAPPDATA\_MEM"
+    }
+}
+
+
+$global:Path_local = Set-LocalPathBasedOnContext
+
+
+
+Write-EnhancedLog -Message "calling Initialize-ScriptVariables" -Level "INFO" -ForegroundColor ([ConsoleColor]::Green)
+    
+#################################################################################################################################
+################################################# END LOGGING ###################################################################
+#################################################################################################################################
+
+
+
+
+
+
+
+
+
+function Initialize-ScriptVariables {
+
+
+    <#
+.SYNOPSIS
+Initializes global script variables and defines the path for storing related files.
+
+.DESCRIPTION
+This function initializes global script variables such as PackageName, PackageUniqueGUID, Version, and ScriptMode. Additionally, it constructs the path where related files will be stored based on the provided parameters.
+
+.PARAMETER PackageName
+The name of the package being processed.
+
+.PARAMETER PackageUniqueGUID
+The unique identifier for the package being processed.
+
+.PARAMETER Version
+The version of the package being processed.
+
+.PARAMETER ScriptMode
+The mode in which the script is being executed (e.g., "Remediation", "PackageName").
+
+.EXAMPLE
+Initialize-ScriptVariables -PackageName "MyPackage" -PackageUniqueGUID "1234-5678" -Version 1 -ScriptMode "Remediation"
+
+This example initializes the script variables with the specified values.
+
+#>
+
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$PackageName,
+
+        [Parameter(Mandatory = $true)]
+        [string]$PackageUniqueGUID,
+
+        [Parameter(Mandatory = $true)]
+        [int]$Version,
+
+        [Parameter(Mandatory = $true)]
+        [string]$ScriptMode,
+
+        [Parameter(Mandatory = $true)]
+        [string]$PackageExecutionContext
+    )
+
+    # Assuming Set-LocalPathBasedOnContext and Test-RunningAsSystem are defined elsewhere
+    # $global:Path_local = Set-LocalPathBasedOnContext
+
+    # Default logic for $Path_local if not set by Set-LocalPathBasedOnContext
+    if (-not $Path_local) {
+        if (Test-RunningAsSystem) {
+            # $Path_local = "$ENV:ProgramFiles\_MEM"
+            $Path_local = "c:\_MEM"
+        }
+        else {
+            $Path_local = "$ENV:LOCALAPPDATA\_MEM"
+        }
+    }
+
+    $Path_PR = "$Path_local\Data\$PackageName-$PackageUniqueGUID"
+    $schtaskName = "$PackageName - $PackageUniqueGUID"
+    $schtaskDescription = "Version $Version"
+
+    try {
+        # Assuming Write-EnhancedLog is defined elsewhere
+        Write-EnhancedLog -Message "Initializing script variables..." -Level "INFO" -ForegroundColor ([System.ConsoleColor]::Green)
+
+        # Returning a hashtable of all the important variables
+        return @{
+            PackageName             = $PackageName
+            PackageUniqueGUID       = $PackageUniqueGUID
+            Version                 = $Version
+            ScriptMode              = $ScriptMode
+            Path_local              = $Path_local
+            Path_PR                 = $Path_PR
+            schtaskName             = $schtaskName
+            schtaskDescription      = $schtaskDescription
+            PackageExecutionContext = $PackageExecutionContext
+        }
+    }
+    catch {
+        Write-Error "An error occurred while initializing script variables: $_"
+    }
+}
+
+# Invocation of the function and storing returned hashtable in a variable
+# $initializationInfo = Initialize-ScriptVariables -PackageName "YourPackageName" -PackageUniqueGUID "YourGUID" -Version 1 -ScriptMode "YourMode"
+
+
+# Call Initialize-ScriptVariables with splatting
+$InitializeScriptVariablesParams = @{
+    PackageName             = $PackageName
+    PackageUniqueGUID       = $PackageUniqueGUID
+    Version                 = $Version
+    ScriptMode              = $ScriptMode
+    PackageExecutionContext = $PackageExecutionContext
+}
+
+$initializationInfo = Initialize-ScriptVariables @InitializeScriptVariablesParams
+
+$initializationInfo
+
+$global:PackageName = $initializationInfo['PackageName']
+$global:PackageUniqueGUID = $initializationInfo['PackageUniqueGUID']
+$global:Version = $initializationInfo['Version']
+$global:ScriptMode = $initializationInfo['ScriptMode']
+$global:Path_local = $initializationInfo['Path_local']
+$global:Path_PR = $initializationInfo['Path_PR']
+$global:schtaskName = $initializationInfo['schtaskName']
+$global:schtaskDescription = $initializationInfo['schtaskDescription']
+$global:PackageExecutionContext = $initializationInfo['PackageExecutionContext']
+
+
+
+# Check if the scheduled task exists and matches the version
+$Task_existing = Get-ScheduledTask -TaskName $schtaskName -ErrorAction SilentlyContinue
+# if ($Task_existing -and $Task_existing.Description -like "Version $Version*") {
+if ($Task_existing -and $Task_existing.Description) {
+    Write-Host "Found it!"
+    exit 0
+}
+else {
+    # Write-Host "Not Found!"
+    exit 1
+}
diff --git a/Examples/webscript/install.ps1 b/Examples/webscript/install.ps1
new file mode 100644
index 0000000..4d1994f
--- /dev/null
+++ b/Examples/webscript/install.ps1
@@ -0,0 +1,302 @@
+param (
+    [Switch]$SimulatingIntune = $false
+)
+
+$currentExecutionPolicy = Get-ExecutionPolicy
+
+# If it's not already set to Bypass, change it
+if ($currentExecutionPolicy -ne 'Bypass') {
+    Write-Host "Setting Execution Policy to Bypass..."
+    Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force
+}
+else {
+    Write-Host "Execution Policy is already set to Bypass."
+}
+
+# ################################################################################################################################
+# ################################################ END Setting Execution Policy ##################################################
+# ################################################################################################################################
+
+# Create a time-stamped folder in the temp directory
+$timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
+$tempFolder = [System.IO.Path]::Combine($env:TEMP, "Ensure-RunningAsSystem_$timestamp")
+
+# Ensure the temp folder exists
+if (-not (Test-Path -Path $tempFolder)) {
+    New-Item -Path $tempFolder -ItemType Directory | Out-Null
+}
+
+# Use the time-stamped temp folder for your paths
+$privateFolderPath = Join-Path -Path $tempFolder -ChildPath "private"
+$PsExec64Path = Join-Path -Path $privateFolderPath -ChildPath "PsExec64.exe"
+
+# Check if running as a web script (no $MyInvocation.MyCommand.Path)
+if (-not $MyInvocation.MyCommand.Path) {
+    Write-Host "Running as web script, downloading and executing locally..."
+
+    # Ensure TLS 1.2 is used for the download
+    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
+
+    # Create a time-stamped folder in the temp directory
+    $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
+    $downloadFolder = Join-Path -Path $env:TEMP -ChildPath "TriggerWindowsUpdates_$timestamp"
+
+    # Ensure the folder exists
+    if (-not (Test-Path -Path $downloadFolder)) {
+        New-Item -Path $downloadFolder -ItemType Directory | Out-Null
+    }
+
+    # Download the script to the time-stamped folder
+    $localScriptPath = Join-Path -Path $downloadFolder -ChildPath "install.ps1"
+    Invoke-WebRequest -Uri "https://raw.githubusercontent.com/aollivierre/WinUpdates/main/PR4B_TriggerWindowsUpdates-v4/install.ps1" -OutFile $localScriptPath
+
+    Write-Host "Downloading config.psd1 file..."
+
+    # Download the config.psd1 file to the time-stamped folder
+    $configFilePath = Join-Path -Path $downloadFolder -ChildPath "config.psd1"
+    Invoke-WebRequest -Uri "https://raw.githubusercontent.com/aollivierre/WinUpdates/main/PR4B_TriggerWindowsUpdates-v4/config.psd1" -OutFile $configFilePath
+
+    # Execute the script locally
+    & $localScriptPath
+
+    Exit # Exit after running the script locally
+}
+
+else {
+    # If running in a regular context, use the actual path of the script
+    $ScriptToRunAsSystem = $MyInvocation.MyCommand.Path
+}
+
+# Ensure the private folder exists before continuing
+if (-not (Test-Path -Path $privateFolderPath)) {
+    New-Item -Path $privateFolderPath -ItemType Directory | Out-Null
+}
+
+
+
+# Conditional check for SimulatingIntune switch
+if ($SimulatingIntune) {
+    # If not running as a web script, run as SYSTEM using PsExec
+    Write-Host "Simulating Intune environment. Running script as SYSTEM..."
+
+    Write-Host "Running as SYSTEM..."
+
+
+    # Call the function to run as SYSTEM
+    $EnsureRunningAsSystemParams = @{
+        PsExec64Path = $PsExec64Path
+        ScriptPath   = $ScriptToRunAsSystem
+        TargetFolder = $privateFolderPath
+    }
+
+    # Run Ensure-RunningAsSystem only if SimulatingIntune is set
+    Ensure-RunningAsSystem @EnsureRunningAsSystemParams
+}
+else {
+    Write-Host "Not simulating Intune. Skipping SYSTEM execution."
+}
+
+
+# ################################################################################################################################
+# ################################################ END CALLING AS SYSTEM (Uncomment for debugging) ###############################
+# ################################################################################################################################
+
+
+# Set environment variable globally for all users
+[System.Environment]::SetEnvironmentVariable('EnvironmentMode', 'prod', 'Machine')
+
+# Retrieve the environment mode (default to 'prod' if not set)
+$mode = $env:EnvironmentMode
+
+#region FIRING UP MODULE STARTER
+#################################################################################################
+#                                                                                               #
+#                                 FIRING UP MODULE STARTER                                      #
+#                                                                                               #
+#################################################################################################
+
+Invoke-Expression (Invoke-RestMethod "https://raw.githubusercontent.com/aollivierre/module-starter/main/Install-EnhancedModuleStarterAO.ps1")
+
+# Define a hashtable for splatting
+$moduleStarterParams = @{
+    Mode                   = 'prod'
+    SkipPSGalleryModules   = $false
+    SkipCheckandElevate    = $false
+    SkipPowerShell7Install = $false
+    SkipEnhancedModules    = $false
+    SkipGitRepos           = $true
+}
+
+# Call the function using the splat
+Invoke-ModuleStarter @moduleStarterParams
+
+#endregion FIRING UP MODULE STARTER
+
+# Toggle based on the environment mode
+switch ($mode) {
+    'dev' {
+        Write-EnhancedLog -Message "Running in development mode" -Level 'WARNING'
+        # Your development logic here
+    }
+    'prod' {
+        Write-EnhancedLog -Message "Running in production mode" -ForegroundColor Green
+        # Your production logic here
+    }
+    default {
+        Write-EnhancedLog -Message "Unknown mode. Defaulting to production." -ForegroundColor Red
+        # Default to production
+    }
+}
+
+
+
+#region HANDLE PSF MODERN LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE PSF MODERN LOGGING                                          #
+#                                                                                               #
+#################################################################################################
+Set-PSFConfig -Fullname 'PSFramework.Logging.FileSystem.ModernLog' -Value $true -PassThru | Register-PSFConfig -Scope SystemDefault
+
+# Define the base logs path and job name
+$JobName = "WindowsUpdates"
+$parentScriptName = Get-ParentScriptName
+Write-EnhancedLog -Message "Parent Script Name: $parentScriptName"
+
+# Call the Get-PSFCSVLogFilePath function to generate the dynamic log file path
+$paramGetPSFCSVLogFilePath = @{
+    LogsPath         = 'C:\Logs\PSF'
+    JobName          = $jobName
+    parentScriptName = $parentScriptName
+}
+
+$csvLogFilePath = Get-PSFCSVLogFilePath @paramGetPSFCSVLogFilePath
+
+$instanceName = "$parentScriptName-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
+
+# Configure the PSFramework logging provider to use CSV format
+$paramSetPSFLoggingProvider = @{
+    Name            = 'logfile'
+    InstanceName    = $instanceName  # Use a unique instance name
+    FilePath        = $csvLogFilePath  # Use the dynamically generated file path
+    Enabled         = $true
+    FileType        = 'CSV'
+    EnableException = $true
+}
+Set-PSFLoggingProvider @paramSetPSFLoggingProvider
+#endregion HANDLE PSF MODERN LOGGING
+
+
+#region HANDLE Transript LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE Transript LOGGING                                           #
+#                                                                                               #
+#################################################################################################
+# Start the script with error handling
+try {
+    # Generate the transcript file path
+    $GetTranscriptFilePathParams = @{
+        TranscriptsPath  = "C:\Logs\Transcript"
+        JobName          = $jobName
+        parentScriptName = $parentScriptName
+    }
+    $transcriptPath = Get-TranscriptFilePath @GetTranscriptFilePathParams
+    
+    # Start the transcript
+    Write-EnhancedLog -Message "Starting transcript at: $transcriptPath"
+    Start-Transcript -Path $transcriptPath
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+}
+#endregion HANDLE Transript LOGGING
+
+try {
+    #region Script Logic
+    #################################################################################################
+    #                                                                                               #
+    #                                    Script Logic                                               #
+    #                                                                                               #
+    #################################################################################################
+
+    ###########################################################################################################################
+    #############################################STARTING THE MAIN SCHEDULED TASK LOGIC HERE###################################
+    ###########################################################################################################################
+
+    # Define the parameters using a hashtable
+    $taskParams = @{
+        ConfigPath = "$PSScriptRoot\config.psd1"
+        FileName   = "HiddenScript.vbs"
+        Scriptroot = "$PSScriptRoot"
+    }
+
+    # Call the function with the splatted parameters
+    CreateAndRegisterScheduledTask @taskParams
+ 
+    #endregion Script Logic
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+} 
+finally {
+    # Ensure that the transcript is stopped even if an error occurs
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+    # 
+
+    
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+}
\ No newline at end of file
diff --git a/Readme.md b/Readme.md
index 2097a85..cc58774 100644
--- a/Readme.md
+++ b/Readme.md
@@ -2,26 +2,106 @@
 
 ### Call using PowerShell:
 
-- Using full URL:
+- **Recommended: Using Web Launcher (downloads all dependencies)**:
     ```powershell
-    powershell -Command "iex (irm https://raw.githubusercontent.com/aollivierre/setuplab/main/setup.ps1)"
+    iex (irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1')
     ```
-
-- Using shortened URLs:
+    
+    Or with parameters:
     ```powershell
-    powershell -Command "iex (irm https://bit.ly/4c3XH76)"
+    & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -SkipValidation -MaxConcurrency 6
     ```
-    
+
+- **Alternative: Direct execution (for simple scripts only)**:
     ```powershell
-    powershell -Command "iex (irm bit.ly/4c3XH76)"
+    powershell -Command "iex (irm https://raw.githubusercontent.com/aollivierre/setuplab/main/main.ps1)"
     ```
+    Note: This method won't work properly as main.ps1 requires additional files (SetupLabCore.psm1 and software-config.json)
+
+Perfect! I've successfully created a modern, modular PowerShell setup framework with the following improvements:
+
+  ≡ƒÜÇ Key Features Implemented:
+
+  1. Modular Architecture
+
+  - SetupLabCore.psm1: Centralized module with all shared functions
+  - software-config.json: Configuration-driven approach for easy management
+  - main.ps1: Clean orchestrator script
+
+  2. Parallel Installation Γ£à
+
+  - Uses PowerShell jobs for concurrent installations
+  - Configurable max concurrency (default: 4)
+  - Real-time progress monitoring
+
+  3. New Software Added Γ£à
+
+  - Google Chrome
+  - Mozilla Firefox
+  - Warp Terminal
+
+  4. Enhanced Features
+
+  - Skip validation option: -SkipValidation parameter
+  - Improved detection: Unified validation across all software
+  - Category filtering: Install only specific categories
+  - Individual software selection: Install specific packages
+
+  5. Better Organization
+
+  - All old scripts archived in Archive/ folder
+  - Centralized logging in Logs/ folder
+  - Clean root directory structure
 
-### If you are already in PowerShell (URL is case sensitive):
+  ≡ƒôª Usage Examples:
 
+  ## Local Execution:
   ```powershell
-  iex (irm bit.ly/4c3XH76)
+  # Install everything with defaults
+  .\main.ps1
+
+  # Skip validation and use 6 concurrent installs
+  .\main.ps1 -SkipValidation -MaxConcurrency 6
+
+  # Install only Development and Browsers categories
+  .\main.ps1 -Categories "Development,Browsers"
+
+  # Install specific software only
+  .\main.ps1 -Software "Git,Chrome,VSCode"
+
+  # List all available software
+  .\main.ps1 -ListSoftware
   ```
 
+  ## Web Execution (no local files required):
+  ```powershell
+  # Install everything with defaults
+  iex (irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1')
+
+  # Skip validation and use 6 concurrent installs
+  & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -SkipValidation -MaxConcurrency 6
+
+  # Install only Development and Browsers categories
+  & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -Categories "Development","Browsers"
+
+  # Install specific software only
+  & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -Software "Git","Chrome","VSCode"
+
+  # List all available software
+  & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -ListSoftware
+  ```
+
+  ≡ƒÄ» Configuration
+
+  Edit software-config.json to:
+  - Enable/disable specific software
+  - Modify download URLs
+  - Change installation arguments
+  - Add new software packages
+
+  The new system maintains all functionality from the original scripts while adding parallel execution, better error handling, and a cleaner architecture!
+
+
 
 
 
diff --git a/SetupLab-WebLauncher.ps1 b/SetupLab-WebLauncher.ps1
new file mode 100644
index 0000000..b72856a
--- /dev/null
+++ b/SetupLab-WebLauncher.ps1
@@ -0,0 +1,226 @@
+#Requires -Version 5.1
+<#
+.SYNOPSIS
+    Web launcher script for SetupLab - Downloads and executes SetupLab from GitHub
+.DESCRIPTION
+    This script downloads the SetupLab components from GitHub to a temporary directory
+    and executes the main script. This allows running SetupLab directly from a URL
+    without manually cloning the repository.
+.PARAMETER BaseUrl
+    Base URL for the GitHub raw content (default: SetupLab main branch)
+.PARAMETER SkipValidation
+    Skip pre-installation validation checks and install all enabled software
+.PARAMETER MaxConcurrency
+    Maximum number of concurrent installations (default: 4)
+.PARAMETER Categories
+    Comma-separated list of categories to install (default: all enabled categories)
+.PARAMETER Software
+    Comma-separated list of specific software names to install
+.PARAMETER ListSoftware
+    List all available software without installing
+.PARAMETER ConfigFile
+    Name of configuration file to download (default: software-config.json)
+.EXAMPLE
+    # Execute directly from web:
+    iex (irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1')
+.EXAMPLE
+    # Execute with parameters:
+    & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -SkipValidation -MaxConcurrency 6
+.EXAMPLE
+    # Download and execute manually:
+    $launcher = "$env:TEMP\SetupLab-WebLauncher.ps1"
+    Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1' -OutFile $launcher
+    & $launcher -Categories "Development,Browsers"
+#>
+
+[CmdletBinding()]
+param(
+    [Parameter(Mandatory = $false)]
+    [string]$BaseUrl = "https://raw.githubusercontent.com/aollivierre/setuplab/main",
+    
+    [Parameter(Mandatory = $false)]
+    [switch]$SkipValidation,
+    
+    [Parameter(Mandatory = $false)]
+    [ValidateRange(1, 10)]
+    [int]$MaxConcurrency = 4,
+    
+    [Parameter(Mandatory = $false)]
+    [string[]]$Categories = @(),
+    
+    [Parameter(Mandatory = $false)]
+    [string[]]$Software = @(),
+    
+    [Parameter(Mandatory = $false)]
+    [switch]$ListSoftware,
+    
+    [Parameter(Mandatory = $false)]
+    [string]$ConfigFile = "software-config.json"
+)
+
+#region Functions
+function Write-WebLog {
+    param(
+        [string]$Message,
+        [string]$Level = "Info"
+    )
+    
+    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $color = switch ($Level) {
+        "Error" { "Red" }
+        "Warning" { "Yellow" }
+        "Success" { "Green" }
+        "Info" { "White" }
+        default { "White" }
+    }
+    
+    Write-Host "[$timestamp] $Message" -ForegroundColor $color
+}
+
+function Test-Url {
+    param([string]$Url)
+    
+    try {
+        $response = Invoke-WebRequest -Uri $Url -Method Head -UseBasicParsing -TimeoutSec 10
+        return $response.StatusCode -eq 200
+    }
+    catch {
+        return $false
+    }
+}
+
+function Download-File {
+    param(
+        [string]$Url,
+        [string]$OutputPath
+    )
+    
+    try {
+        Write-WebLog "Downloading: $Url" -Level Info
+        
+        # Ensure TLS 1.2 is enabled
+        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
+        
+        # Download the file
+        Invoke-WebRequest -Uri $Url -OutFile $OutputPath -UseBasicParsing -ErrorAction Stop
+        
+        if (Test-Path $OutputPath) {
+            Write-WebLog "Successfully downloaded to: $OutputPath" -Level Success
+            return $true
+        }
+        else {
+            Write-WebLog "Download appeared to succeed but file not found: $OutputPath" -Level Error
+            return $false
+        }
+    }
+    catch {
+        Write-WebLog "Failed to download $Url : $_" -Level Error
+        return $false
+    }
+}
+#endregion
+
+#region Main Execution
+Write-WebLog "SetupLab Web Launcher" -Level Info
+Write-WebLog ("=" * 60) -Level Info
+
+# Ensure BaseUrl doesn't end with a slash
+$BaseUrl = $BaseUrl.TrimEnd('/')
+
+# Create temporary directory
+$tempDir = Join-Path $env:TEMP "SetupLab_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
+Write-WebLog "Creating temporary directory: $tempDir" -Level Info
+
+try {
+    New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
+}
+catch {
+    Write-WebLog "Failed to create temporary directory: $_" -Level Error
+    exit 1
+}
+
+# Define files to download
+$filesToDownload = @(
+    @{
+        Name = "main.ps1"
+        Url = "$BaseUrl/main.ps1"
+        Required = $true
+    },
+    @{
+        Name = "SetupLabCore.psm1"
+        Url = "$BaseUrl/SetupLabCore.psm1"
+        Required = $true
+    },
+    @{
+        Name = $ConfigFile
+        Url = "$BaseUrl/$ConfigFile"
+        Required = $true
+    }
+)
+
+# Download all required files
+$downloadSuccess = $true
+foreach ($file in $filesToDownload) {
+    $outputPath = Join-Path $tempDir $file.Name
+    
+    if (-not (Download-File -Url $file.Url -OutputPath $outputPath)) {
+        if ($file.Required) {
+            Write-WebLog "Failed to download required file: $($file.Name)" -Level Error
+            $downloadSuccess = $false
+            break
+        }
+        else {
+            Write-WebLog "Failed to download optional file: $($file.Name), continuing..." -Level Warning
+        }
+    }
+}
+
+if (-not $downloadSuccess) {
+    Write-WebLog "Failed to download all required files. Cleaning up..." -Level Error
+    Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
+    exit 1
+}
+
+Write-WebLog "" -Level Info
+Write-WebLog "All required files downloaded successfully" -Level Success
+Write-WebLog "" -Level Info
+
+# Build parameters for main.ps1
+$mainScriptPath = Join-Path $tempDir "main.ps1"
+$mainParams = @{}
+
+if ($SkipValidation) { $mainParams['SkipValidation'] = $true }
+if ($PSBoundParameters.ContainsKey('MaxConcurrency')) { $mainParams['MaxConcurrency'] = $MaxConcurrency }
+if ($Categories.Count -gt 0) { $mainParams['Categories'] = $Categories }
+if ($Software.Count -gt 0) { $mainParams['Software'] = $Software }
+if ($ListSoftware) { $mainParams['ListSoftware'] = $true }
+if ($PSBoundParameters.ContainsKey('ConfigFile')) { $mainParams['ConfigFile'] = $ConfigFile }
+
+# Execute main.ps1
+try {
+    Write-WebLog "Executing SetupLab main script..." -Level Info
+    Write-WebLog "" -Level Info
+    
+    # Change to temp directory to ensure relative paths work
+    Push-Location $tempDir
+    
+    # Execute the script
+    & $mainScriptPath @mainParams
+    
+    # Return to original directory
+    Pop-Location
+}
+catch {
+    Pop-Location
+    Write-WebLog "Error executing main script: $_" -Level Error
+    exit 1
+}
+finally {
+    # Cleanup temporary directory
+    Write-WebLog "" -Level Info
+    Write-WebLog "Cleaning up temporary files..." -Level Info
+    Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
+}
+
+Write-WebLog "SetupLab Web Launcher completed" -Level Success
+#endregion
\ No newline at end of file
diff --git a/Test-WebLauncher.ps1 b/Test-WebLauncher.ps1
new file mode 100644
index 0000000..c206f4f
--- /dev/null
+++ b/Test-WebLauncher.ps1
@@ -0,0 +1,93 @@
+#Requires -Version 5.1
+<#
+.SYNOPSIS
+    Test script for SetupLab Web Launcher
+.DESCRIPTION
+    This script tests the web launcher functionality by simulating web execution locally
+.EXAMPLE
+    .\Test-WebLauncher.ps1
+    Tests basic functionality
+.EXAMPLE
+    .\Test-WebLauncher.ps1 -TestListSoftware
+    Tests the ListSoftware functionality
+#>
+
+[CmdletBinding()]
+param(
+    [switch]$TestListSoftware,
+    [switch]$TestWithParameters,
+    [switch]$UseGitHubUrl
+)
+
+Write-Host "SetupLab Web Launcher Test Script" -ForegroundColor Cyan
+Write-Host ("=" * 60) -ForegroundColor Cyan
+Write-Host ""
+
+# Test 1: Test local execution of web launcher
+if (-not $UseGitHubUrl) {
+    Write-Host "Test 1: Testing local web launcher execution" -ForegroundColor Yellow
+    Write-Host "This simulates what would happen when running from GitHub" -ForegroundColor Gray
+    Write-Host ""
+    
+    $launcherPath = Join-Path $PSScriptRoot "SetupLab-WebLauncher.ps1"
+    
+    if (-not (Test-Path $launcherPath)) {
+        Write-Host "ERROR: SetupLab-WebLauncher.ps1 not found at: $launcherPath" -ForegroundColor Red
+        exit 1
+    }
+    
+    # Test basic list functionality
+    if ($TestListSoftware) {
+        Write-Host "Testing ListSoftware parameter..." -ForegroundColor Green
+        & $launcherPath -ListSoftware -BaseUrl "file:///$PSScriptRoot"
+    }
+    elseif ($TestWithParameters) {
+        Write-Host "Testing with parameters (SkipValidation, MaxConcurrency=2)..." -ForegroundColor Green
+        Write-Host "NOTE: This will actually try to install software!" -ForegroundColor Red
+        Write-Host "Press CTRL+C within 5 seconds to cancel..." -ForegroundColor Yellow
+        Start-Sleep -Seconds 5
+        & $launcherPath -SkipValidation -MaxConcurrency 2 -Categories "Development" -BaseUrl "file:///$PSScriptRoot"
+    }
+    else {
+        Write-Host "Testing basic execution (ListSoftware only for safety)..." -ForegroundColor Green
+        & $launcherPath -ListSoftware -BaseUrl "file:///$PSScriptRoot"
+    }
+}
+else {
+    # Test 2: Test actual GitHub URL execution
+    Write-Host "Test 2: Testing actual GitHub URL execution" -ForegroundColor Yellow
+    Write-Host "This will download from the actual GitHub repository" -ForegroundColor Gray
+    Write-Host ""
+    
+    $githubUrl = 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'
+    
+    Write-Host "Testing with GitHub URL: $githubUrl" -ForegroundColor Green
+    Write-Host "Executing: & ([scriptblock]::Create((irm '$githubUrl'))) -ListSoftware" -ForegroundColor Gray
+    Write-Host ""
+    
+    try {
+        & ([scriptblock]::Create((Invoke-RestMethod -Uri $githubUrl))) -ListSoftware
+        Write-Host ""
+        Write-Host "SUCCESS: Web launcher executed successfully from GitHub!" -ForegroundColor Green
+    }
+    catch {
+        Write-Host "ERROR: Failed to execute web launcher from GitHub" -ForegroundColor Red
+        Write-Host "Error: $_" -ForegroundColor Red
+    }
+}
+
+Write-Host ""
+Write-Host "Test completed!" -ForegroundColor Cyan
+
+# Show example commands for manual testing
+Write-Host ""
+Write-Host "Example commands for manual testing:" -ForegroundColor Yellow
+Write-Host ""
+Write-Host "1. List software (safe):" -ForegroundColor White
+Write-Host "   iex (irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1') -ListSoftware" -ForegroundColor Gray
+Write-Host ""
+Write-Host "2. With parameters:" -ForegroundColor White
+Write-Host "   & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -ListSoftware" -ForegroundColor Gray
+Write-Host ""
+Write-Host "3. Install specific categories:" -ForegroundColor White
+Write-Host "   & ([scriptblock]::Create((irm 'https://raw.githubusercontent.com/aollivierre/setuplab/main/SetupLab-WebLauncher.ps1'))) -Categories 'Development','Browsers' -SkipValidation" -ForegroundColor Gray
\ No newline at end of file
